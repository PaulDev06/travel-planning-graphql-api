{"version":3,"file":"6610.js","mappings":"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","sources":["webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/equals.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/promise.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/lazyObservableValue.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/api.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { DisposableStore, markAsDisposed, toDisposable, trackDisposable } from '../lifecycle.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn) {\n    return new AutorunObserver(new DebugNameData(undefined, undefined, fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options, fn) {\n    return new AutorunObserver(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges(options, fn) {\n    return new AutorunObserver(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, options.createEmptyChangeSummary, options.handleChange);\n}\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStoreHandleChanges(options, fn) {\n    const store = new DisposableStore();\n    const disposable = autorunHandleChanges({\n        owner: options.owner,\n        debugName: options.debugName,\n        debugReferenceFn: options.debugReferenceFn ?? fn,\n        createEmptyChangeSummary: options.createEmptyChangeSummary,\n        handleChange: options.handleChange,\n    }, (reader, changeSummary) => {\n        store.clear();\n        fn(reader, changeSummary, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStore(fn) {\n    const store = new DisposableStore();\n    const disposable = autorunOpts({\n        owner: undefined,\n        debugName: undefined,\n        debugReferenceFn: fn,\n    }, reader => {\n        store.clear();\n        fn(reader, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\nexport class AutorunObserver {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _runFn, createChangeSummary, _handleChange) {\n        this._debugNameData = _debugNameData;\n        this._runFn = _runFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this.state = 2 /* AutorunState.stale */;\n        this.updateCount = 0;\n        this.disposed = false;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = this.createChangeSummary?.();\n        getLogger()?.handleAutorunCreated(this);\n        this._runIfNeeded();\n        trackDisposable(this);\n    }\n    dispose() {\n        this.disposed = true;\n        for (const o of this.dependencies) {\n            o.removeObserver(this);\n        }\n        this.dependencies.clear();\n        markAsDisposed(this);\n    }\n    _runIfNeeded() {\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        this.state = 3 /* AutorunState.upToDate */;\n        const isDisposed = this.disposed;\n        try {\n            if (!isDisposed) {\n                getLogger()?.handleAutorunTriggered(this);\n                const changeSummary = this.changeSummary;\n                this.changeSummary = this.createChangeSummary?.();\n                this._runFn(this, changeSummary);\n            }\n        }\n        finally {\n            if (!isDisposed) {\n                getLogger()?.handleAutorunFinished(this);\n            }\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n    }\n    toString() {\n        return `Autorun<${this.debugName}>`;\n    }\n    // IObserver implementation\n    beginUpdate() {\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n        this.updateCount++;\n    }\n    endUpdate() {\n        if (this.updateCount === 1) {\n            do {\n                if (this.state === 1 /* AutorunState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* AutorunState.upToDate */;\n                    for (const d of this.dependencies) {\n                        d.reportChanges();\n                        if (this.state === 2 /* AutorunState.stale */) {\n                            // The other dependencies will refresh on demand\n                            break;\n                        }\n                    }\n                }\n                this._runIfNeeded();\n            } while (this.state !== 3 /* AutorunState.upToDate */);\n        }\n        this.updateCount--;\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        if (this.state === 3 /* AutorunState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: (o) => o === observable,\n            }, this.changeSummary) : true;\n            if (shouldReact) {\n                this.state = 2 /* AutorunState.stale */;\n            }\n        }\n    }\n    // IReader implementation\n    readObservable(observable) {\n        // In case the run action disposes the autorun\n        if (this.disposed) {\n            return observable.get();\n        }\n        observable.addObserver(this);\n        const value = observable.get();\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n}\n(function (autorun) {\n    autorun.Observer = AutorunObserver;\n})(autorun || (autorun = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from './arrays.js';\n/**\n * Compares two items for equality using strict equality.\n*/\nexport const strictEquals = (a, b) => a === b;\n/**\n * Checks if the items of two arrays are equal.\n * By default, strict equality is used to compare elements, but a custom equality comparer can be provided.\n */\nexport function itemsEquals(itemEquals = strictEquals) {\n    return (a, b) => arrays.equals(a, b, itemEquals);\n}\n/**\n * Uses `item.equals(other)` to determine equality.\n */\nexport function itemEquals() {\n    return (a, b) => a.equals(b);\n}\nexport function equalsIfDefined(equalsOrV1, v2, equals) {\n    if (equals !== undefined) {\n        const v1 = equalsOrV1;\n        if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n            return v2 === v1;\n        }\n        return equals(v1, v2);\n    }\n    else {\n        const equals = equalsOrV1;\n        return (v1, v2) => {\n            if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n                return v2 === v1;\n            }\n            return equals(v1, v2);\n        };\n    }\n}\n/**\n * Drills into arrays (items ordered) and objects (keys unordered) and uses strict equality on everything else.\n*/\nexport function structuralEquals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n            if (!structuralEquals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (a && typeof a === 'object' && b && typeof b === 'object') {\n        if (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {\n            const aObj = a;\n            const bObj = b;\n            const keysA = Object.keys(aObj);\n            const keysB = Object.keys(bObj);\n            const keysBSet = new Set(keysB);\n            if (keysA.length !== keysB.length) {\n                return false;\n            }\n            for (const key of keysA) {\n                if (!keysBSet.has(key)) {\n                    return false;\n                }\n                if (!structuralEquals(aObj[key], bObj[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}\nconst objIds = new WeakMap();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { autorun } from './autorun.js';\nimport { observableValue, transaction } from './base.js';\nimport { CancellationError } from '../errors.js';\n/**\n * A promise whose state is observable.\n */\nexport class ObservablePromise {\n    static fromFn(fn) {\n        return new ObservablePromise(fn());\n    }\n    constructor(promise) {\n        this._value = observableValue(this, undefined);\n        /**\n         * The current state of the promise.\n         * Is `undefined` if the promise didn't resolve yet.\n         */\n        this.promiseResult = this._value;\n        this.promise = promise.then(value => {\n            transaction(tx => {\n                /** @description onPromiseResolved */\n                this._value.set(new PromiseResult(value, undefined), tx);\n            });\n            return value;\n        }, error => {\n            transaction(tx => {\n                /** @description onPromiseRejected */\n                this._value.set(new PromiseResult(undefined, error), tx);\n            });\n            throw error;\n        });\n    }\n}\nexport class PromiseResult {\n    constructor(\n    /**\n     * The value of the resolved promise.\n     * Undefined if the promise rejected.\n     */\n    data, \n    /**\n     * The error in case of a rejected promise.\n     * Undefined if the promise resolved.\n     */\n    error) {\n        this.data = data;\n        this.error = error;\n    }\n}\nexport function waitForState(observable, predicate, isError, cancellationToken) {\n    if (!predicate) {\n        predicate = state => state !== null && state !== undefined;\n    }\n    return new Promise((resolve, reject) => {\n        let isImmediateRun = true;\n        let shouldDispose = false;\n        const stateObs = observable.map(state => {\n            /** @description waitForState.state */\n            return {\n                isFinished: predicate(state),\n                error: isError ? isError(state) : false,\n                state\n            };\n        });\n        const d = autorun(reader => {\n            /** @description waitForState */\n            const { isFinished, error, state } = stateObs.read(reader);\n            if (isFinished || error) {\n                if (isImmediateRun) {\n                    // The variable `d` is not initialized yet\n                    shouldDispose = true;\n                }\n                else {\n                    d.dispose();\n                }\n                if (error) {\n                    reject(error === true ? state : error);\n                }\n                else {\n                    resolve(state);\n                }\n            }\n        });\n        if (cancellationToken) {\n            const dc = cancellationToken.onCancellationRequested(() => {\n                d.dispose();\n                dc.dispose();\n                reject(new CancellationError());\n            });\n            if (cancellationToken.isCancellationRequested) {\n                d.dispose();\n                dc.dispose();\n                reject(new CancellationError());\n                return;\n            }\n        }\n        isImmediateRun = false;\n        if (shouldDispose) {\n            d.dispose();\n        }\n    });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { strictEquals } from '../equals.js';\nimport { DebugNameData, getFunctionName } from './debugName.js';\nimport { getLogger } from './logging.js';\nlet _recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {\n    _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\nlet _keepObserved;\nexport function _setKeepObserved(keepObserved) {\n    _keepObserved = keepObserved;\n}\nlet _derived;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived) {\n    _derived = derived;\n}\nexport class ConvenientObservable {\n    get TChange() { return null; }\n    reportChanges() {\n        this.get();\n    }\n    /** @sealed */\n    read(reader) {\n        if (reader) {\n            return reader.readObservable(this);\n        }\n        else {\n            return this.get();\n        }\n    }\n    map(fnOrOwner, fnOrUndefined) {\n        const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;\n        const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;\n        return _derived({\n            owner,\n            debugName: () => {\n                const name = getFunctionName(fn);\n                if (name !== undefined) {\n                    return name;\n                }\n                // regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n                const regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n                const match = regexp.exec(fn.toString());\n                if (match) {\n                    return `${this.debugName}.${match[2]}`;\n                }\n                if (!owner) {\n                    return `${this.debugName} (mapped)`;\n                }\n                return undefined;\n            },\n            debugReferenceFn: fn,\n        }, (reader) => fn(this.read(reader), reader));\n    }\n    /**\n     * @sealed\n     * Converts an observable of an observable value into a direct observable of the value.\n    */\n    flatten() {\n        return _derived({\n            owner: undefined,\n            debugName: () => `${this.debugName} (flattened)`,\n        }, (reader) => this.read(reader).read(reader));\n    }\n    recomputeInitiallyAndOnChange(store, handleValue) {\n        store.add(_recomputeInitiallyAndOnChange(this, handleValue));\n        return this;\n    }\n    /**\n     * Ensures that this observable is observed. This keeps the cache alive.\n     * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).\n     * Use `recomputeInitiallyAndOnChange` for eager evaluation.\n     */\n    keepObserved(store) {\n        store.add(_keepObserved(this));\n        return this;\n    }\n}\nexport class BaseObservable extends ConvenientObservable {\n    constructor() {\n        super(...arguments);\n        this.observers = new Set();\n    }\n    addObserver(observer) {\n        const len = this.observers.size;\n        this.observers.add(observer);\n        if (len === 0) {\n            this.onFirstObserverAdded();\n        }\n    }\n    removeObserver(observer) {\n        const deleted = this.observers.delete(observer);\n        if (deleted && this.observers.size === 0) {\n            this.onLastObserverRemoved();\n        }\n    }\n    onFirstObserverAdded() { }\n    onLastObserverRemoved() { }\n}\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\nexport function transaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\nlet _globalTransaction = undefined;\nexport function globalTransaction(fn) {\n    if (_globalTransaction) {\n        fn(_globalTransaction);\n    }\n    else {\n        const tx = new TransactionImpl(fn, undefined);\n        _globalTransaction = tx;\n        try {\n            fn(tx);\n        }\n        finally {\n            tx.finish(); // During finish, more actions might be added to the transaction.\n            // Which is why we only clear the global transaction after finish.\n            _globalTransaction = undefined;\n        }\n    }\n}\nexport async function asyncTransaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        await fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\n/**\n * Allows to chain transactions.\n */\nexport function subtransaction(tx, fn, getDebugName) {\n    if (!tx) {\n        transaction(fn, getDebugName);\n    }\n    else {\n        fn(tx);\n    }\n}\nexport class TransactionImpl {\n    constructor(_fn, _getDebugName) {\n        this._fn = _fn;\n        this._getDebugName = _getDebugName;\n        this.updatingObservers = [];\n        getLogger()?.handleBeginTransaction(this);\n    }\n    getDebugName() {\n        if (this._getDebugName) {\n            return this._getDebugName();\n        }\n        return getFunctionName(this._fn);\n    }\n    updateObserver(observer, observable) {\n        // When this gets called while finish is active, they will still get considered\n        this.updatingObservers.push({ observer, observable });\n        observer.beginUpdate(observable);\n    }\n    finish() {\n        const updatingObservers = this.updatingObservers;\n        for (let i = 0; i < updatingObservers.length; i++) {\n            const { observer, observable } = updatingObservers[i];\n            observer.endUpdate(observable);\n        }\n        // Prevent anyone from updating observers from now on.\n        this.updatingObservers = null;\n        getLogger()?.handleEndTransaction();\n    }\n}\nexport function observableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new ObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class ObservableValue extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'ObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._value = initialValue;\n    }\n    get() {\n        return this._value;\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            const oldValue = this._value;\n            this._setValue(value);\n            getLogger()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n            for (const observer of this.observers) {\n                tx.updateObserver(observer, this);\n                observer.handleChange(this, change);\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nexport function disposableObservableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new DisposableObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class DisposableObservableValue extends ObservableValue {\n    _setValue(newValue) {\n        if (this._value === newValue) {\n            return;\n        }\n        if (this._value) {\n            this._value.dispose();\n        }\n        this._value = newValue;\n    }\n    dispose() {\n        this._value?.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BaseObservable, TransactionImpl } from './base.js';\n/**\n * Holds off updating observers until the value is actually read.\n*/\nexport class LazyObservableValue extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'LazyObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._isUpToDate = true;\n        this._deltas = [];\n        this._updateCounter = 0;\n        this._value = initialValue;\n    }\n    get() {\n        this._update();\n        return this._value;\n    }\n    _update() {\n        if (this._isUpToDate) {\n            return;\n        }\n        this._isUpToDate = true;\n        if (this._deltas.length > 0) {\n            for (const observer of this.observers) {\n                for (const change of this._deltas) {\n                    observer.handleChange(this, change);\n                }\n            }\n            this._deltas.length = 0;\n        }\n        else {\n            for (const observer of this.observers) {\n                observer.handleChange(this, undefined);\n            }\n        }\n    }\n    _beginUpdate() {\n        this._updateCounter++;\n        if (this._updateCounter === 1) {\n            for (const observer of this.observers) {\n                observer.beginUpdate(this);\n            }\n        }\n    }\n    _endUpdate() {\n        this._updateCounter--;\n        if (this._updateCounter === 0) {\n            this._update();\n            // End update could change the observer list.\n            const observers = [...this.observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this.observers.has(observer) && this._updateCounter > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = this.observers.has(observer) && this._updateCounter > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n            observer.endUpdate(this);\n        }\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            this._isUpToDate = false;\n            this._setValue(value);\n            if (change !== undefined) {\n                this._deltas.push(change);\n            }\n            tx.updateObserver({\n                beginUpdate: () => this._beginUpdate(),\n                endUpdate: () => this._endUpdate(),\n                handleChange: (observable, change) => { },\n                handlePossibleChange: (observable) => { },\n            }, this);\n            if (this._updateCounter > 1) {\n                // We already started begin/end update, so we need to manually call handlePossibleChange\n                for (const observer of this.observers) {\n                    observer.handlePossibleChange(this);\n                }\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { strictEquals } from '../equals.js';\nimport { ObservableValue } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { LazyObservableValue } from './lazyObservableValue.js';\nexport function observableValueOpts(options, initialValue) {\n    if (options.lazy) {\n        return new LazyObservableValue(new DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? strictEquals);\n    }\n    return new ObservableValue(new DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? strictEquals);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class DebugNameData {\n    constructor(owner, debugNameSource, referenceFn) {\n        this.owner = owner;\n        this.debugNameSource = debugNameSource;\n        this.referenceFn = referenceFn;\n    }\n    getDebugName(target) {\n        return getDebugName(target, this);\n    }\n}\nconst countPerName = new Map();\nconst cachedDebugName = new WeakMap();\nexport function getDebugName(target, data) {\n    const cached = cachedDebugName.get(target);\n    if (cached) {\n        return cached;\n    }\n    const dbgName = computeDebugName(target, data);\n    if (dbgName) {\n        let count = countPerName.get(dbgName) ?? 0;\n        count++;\n        countPerName.set(dbgName, count);\n        const result = count === 1 ? dbgName : `${dbgName}#${count}`;\n        cachedDebugName.set(target, result);\n        return result;\n    }\n    return undefined;\n}\nfunction computeDebugName(self, data) {\n    const cached = cachedDebugName.get(self);\n    if (cached) {\n        return cached;\n    }\n    const ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';\n    let result;\n    const debugNameSource = data.debugNameSource;\n    if (debugNameSource !== undefined) {\n        if (typeof debugNameSource === 'function') {\n            result = debugNameSource();\n            if (result !== undefined) {\n                return ownerStr + result;\n            }\n        }\n        else {\n            return ownerStr + debugNameSource;\n        }\n    }\n    const referenceFn = data.referenceFn;\n    if (referenceFn !== undefined) {\n        result = getFunctionName(referenceFn);\n        if (result !== undefined) {\n            return ownerStr + result;\n        }\n    }\n    if (data.owner !== undefined) {\n        const key = findKey(data.owner, self);\n        if (key !== undefined) {\n            return ownerStr + key;\n        }\n    }\n    return undefined;\n}\nfunction findKey(obj, value) {\n    for (const key in obj) {\n        if (obj[key] === value) {\n            return key;\n        }\n    }\n    return undefined;\n}\nconst countPerClassName = new Map();\nconst ownerId = new WeakMap();\nfunction formatOwner(owner) {\n    const id = ownerId.get(owner);\n    if (id) {\n        return id;\n    }\n    const className = getClassName(owner);\n    let count = countPerClassName.get(className) ?? 0;\n    count++;\n    countPerClassName.set(className, count);\n    const result = count === 1 ? className : `${className}#${count}`;\n    ownerId.set(owner, result);\n    return result;\n}\nfunction getClassName(obj) {\n    const ctor = obj.constructor;\n    if (ctor) {\n        return ctor.name;\n    }\n    return 'Object';\n}\nexport function getFunctionName(fn) {\n    const fnSrc = fn.toString();\n    // Pattern: /** @description ... */\n    const regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n    const match = regexp.exec(fnSrc);\n    const result = match ? match[1] : undefined;\n    return result?.trim();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { strictEquals } from '../equals.js';\nimport { DisposableStore } from '../lifecycle.js';\nimport { BaseObservable, _setDerivedOpts } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\nexport function derived(computeFnOrOwner, computeFn) {\n    if (computeFn !== undefined) {\n        return new Derived(new DebugNameData(computeFnOrOwner, undefined, computeFn), computeFn, undefined, undefined, undefined, strictEquals);\n    }\n    return new Derived(new DebugNameData(undefined, undefined, computeFnOrOwner), computeFnOrOwner, undefined, undefined, undefined, strictEquals);\n}\nexport function derivedWithSetter(owner, computeFn, setter) {\n    return new DerivedWithSetter(new DebugNameData(owner, undefined, computeFn), computeFn, undefined, undefined, undefined, strictEquals, setter);\n}\nexport function derivedOpts(options, computeFn) {\n    return new Derived(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn), computeFn, undefined, undefined, options.onLastObserverRemoved, options.equalsFn ?? strictEquals);\n}\n_setDerivedOpts(derivedOpts);\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges(options, computeFn) {\n    return new Derived(new DebugNameData(options.owner, options.debugName, undefined), computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, options.equalityComparer ?? strictEquals);\n}\nexport function derivedWithStore(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    const store = new DisposableStore();\n    return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n        store.clear();\n        return computeFn(r, store);\n    }, undefined, undefined, () => store.dispose(), strictEquals);\n}\nexport function derivedDisposable(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    let store = undefined;\n    return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n        if (!store) {\n            store = new DisposableStore();\n        }\n        else {\n            store.clear();\n        }\n        const result = computeFn(r);\n        if (result) {\n            store.add(result);\n        }\n        return result;\n    }, undefined, undefined, () => {\n        if (store) {\n            store.dispose();\n            store = undefined;\n        }\n    }, strictEquals);\n}\nexport class Derived extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _computeFn, createChangeSummary, _handleChange, _handleLastObserverRemoved = undefined, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._computeFn = _computeFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this._handleLastObserverRemoved = _handleLastObserverRemoved;\n        this._equalityComparator = _equalityComparator;\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        this.updateCount = 0;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = undefined;\n        this.changeSummary = this.createChangeSummary?.();\n        getLogger()?.handleDerivedCreated(this);\n    }\n    onLastObserverRemoved() {\n        /**\n         * We are not tracking changes anymore, thus we have to assume\n         * that our cache is invalid.\n         */\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        for (const d of this.dependencies) {\n            d.removeObserver(this);\n        }\n        this.dependencies.clear();\n        this._handleLastObserverRemoved?.();\n    }\n    get() {\n        if (this.observers.size === 0) {\n            // Without observers, we don't know when to clean up stuff.\n            // Thus, we don't cache anything to prevent memory leaks.\n            const result = this._computeFn(this, this.createChangeSummary?.());\n            // Clear new dependencies\n            this.onLastObserverRemoved();\n            return result;\n        }\n        else {\n            do {\n                // We might not get a notification for a dependency that changed while it is updating,\n                // thus we also have to ask all our depedencies if they changed in this case.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    for (const d of this.dependencies) {\n                        /** might call {@link handleChange} indirectly, which could make us stale */\n                        d.reportChanges();\n                        if (this.state === 2 /* DerivedState.stale */) {\n                            // The other dependencies will refresh on demand, so early break\n                            break;\n                        }\n                    }\n                }\n                // We called report changes of all dependencies.\n                // If we are still not stale, we can assume to be up to date again.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* DerivedState.upToDate */;\n                }\n                this._recomputeIfNeeded();\n                // In case recomputation changed one of our dependencies, we need to recompute again.\n            } while (this.state !== 3 /* DerivedState.upToDate */);\n            return this.value;\n        }\n    }\n    _recomputeIfNeeded() {\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        const hadValue = this.state !== 0 /* DerivedState.initial */;\n        const oldValue = this.value;\n        this.state = 3 /* DerivedState.upToDate */;\n        const changeSummary = this.changeSummary;\n        this.changeSummary = this.createChangeSummary?.();\n        try {\n            /** might call {@link handleChange} indirectly, which could invalidate us */\n            this.value = this._computeFn(this, changeSummary);\n        }\n        finally {\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n        const didChange = hadValue && !(this._equalityComparator(oldValue, this.value));\n        getLogger()?.handleDerivedRecomputed(this, {\n            oldValue,\n            newValue: this.value,\n            change: undefined,\n            didChange,\n            hadValue,\n        });\n        if (didChange) {\n            for (const r of this.observers) {\n                r.handleChange(this, undefined);\n            }\n        }\n    }\n    toString() {\n        return `LazyDerived<${this.debugName}>`;\n    }\n    // IObserver Implementation\n    beginUpdate(_observable) {\n        this.updateCount++;\n        const propagateBeginUpdate = this.updateCount === 1;\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            // If we propagate begin update, that will already signal a possible change.\n            if (!propagateBeginUpdate) {\n                for (const r of this.observers) {\n                    r.handlePossibleChange(this);\n                }\n            }\n        }\n        if (propagateBeginUpdate) {\n            for (const r of this.observers) {\n                r.beginUpdate(this); // This signals a possible change\n            }\n        }\n    }\n    endUpdate(_observable) {\n        this.updateCount--;\n        if (this.updateCount === 0) {\n            // End update could change the observer list.\n            const observers = [...this.observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        // In all other states, observers already know that we might have changed.\n        if (this.state === 3 /* DerivedState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            for (const r of this.observers) {\n                r.handlePossibleChange(this);\n            }\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: (o) => o === observable,\n            }, this.changeSummary) : true;\n            const wasUpToDate = this.state === 3 /* DerivedState.upToDate */;\n            if (shouldReact && (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */ || wasUpToDate)) {\n                this.state = 2 /* DerivedState.stale */;\n                if (wasUpToDate) {\n                    for (const r of this.observers) {\n                        r.handlePossibleChange(this);\n                    }\n                }\n            }\n        }\n    }\n    // IReader Implementation\n    readObservable(observable) {\n        // Subscribe before getting the value to enable caching\n        observable.addObserver(this);\n        /** This might call {@link handleChange} indirectly, which could invalidate us */\n        const value = observable.get();\n        // Which is why we only add the observable to the dependencies now.\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n            observer.endUpdate(this);\n        }\n    }\n}\nexport class DerivedWithSetter extends Derived {\n    constructor(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved = undefined, equalityComparator, set) {\n        super(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved, equalityComparator);\n        this.set = set;\n    }\n}\n"],"names":["autorun","fn","AutorunObserver","undefined","autorunOpts","options","owner","debugName","debugReferenceFn","autorunHandleChanges","createEmptyChangeSummary","handleChange","autorunWithStoreHandleChanges","store","disposable","reader","changeSummary","clear","dispose","autorunWithStore","this","_debugNameData","getDebugName","constructor","_runFn","createChangeSummary","_handleChange","state","updateCount","disposed","dependencies","Set","dependenciesToBeRemoved","handleAutorunCreated","_runIfNeeded","o","removeObserver","emptySet","isDisposed","handleAutorunTriggered","handleAutorunFinished","toString","beginUpdate","endUpdate","d","reportChanges","handlePossibleChange","observable","has","change","changedObservable","didChange","readObservable","get","addObserver","value","add","delete","Observer","strictEquals","a","b","itemsEquals","itemEquals","equals","equalsIfDefined","equalsOrV1","v2","v1","structuralEquals","Array","isArray","length","i","Object","getPrototypeOf","prototype","aObj","bObj","keysA","keys","keysB","keysBSet","key","WeakMap","ObservablePromise","fromFn","promise","_value","promiseResult","then","tx","set","PromiseResult","error","data","waitForState","predicate","isError","cancellationToken","Promise","resolve","reject","isImmediateRun","shouldDispose","stateObs","map","isFinished","read","dc","onCancellationRequested","isCancellationRequested","_recomputeInitiallyAndOnChange","_keepObserved","_derived","_setRecomputeInitiallyAndOnChange","recomputeInitiallyAndOnChange","_setKeepObserved","keepObserved","_setDerivedOpts","derived","ConvenientObservable","TChange","fnOrOwner","fnOrUndefined","name","match","exec","flatten","handleValue","BaseObservable","super","arguments","observers","observer","len","size","onFirstObserverAdded","onLastObserverRemoved","transaction","TransactionImpl","finish","_globalTransaction","globalTransaction","async","asyncTransaction","subtransaction","_fn","_getDebugName","updatingObservers","handleBeginTransaction","updateObserver","push","handleEndTransaction","observableValue","nameOrOwner","initialValue","debugNameData","ObservableValue","_equalityComparator","_tx","oldValue","_setValue","handleObservableChanged","newValue","hadValue","disposableObservableValue","DisposableObservableValue","LazyObservableValue","_isUpToDate","_deltas","_updateCounter","_update","_beginUpdate","_endUpdate","r","shouldCallBeginUpdate","shouldCallEndUpdate","observableValueOpts","lazy","equalsFn","DebugNameData","debugNameSource","referenceFn","target","cached","cachedDebugName","dbgName","self","ownerStr","id","ownerId","className","obj","ctor","getClassName","count","countPerClassName","result","formatOwner","getFunctionName","findKey","computeDebugName","countPerName","Map","fnSrc","trim","computeFnOrOwner","computeFn","Derived","derivedWithSetter","setter","DerivedWithSetter","derivedOpts","derivedHandleChanges","equalityComparer","derivedWithStore","computeFnOrUndefined","derivedDisposable","_computeFn","_handleLastObserverRemoved","handleDerivedCreated","_recomputeIfNeeded","handleDerivedRecomputed","_observable","propagateBeginUpdate","shouldReact","wasUpToDate","handleLastObserverRemoved","equalityComparator"],"sourceRoot":""}